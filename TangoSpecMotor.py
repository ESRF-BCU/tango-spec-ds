#!/usr/bin/env python
#    "$Name:  $";
#    "$Header:  $";
#=============================================================================
#
# file :        TangoSpecMotor.py
#
# description : Python source for the TangoSpecMotor and its commands. 
#                The class is derived from Device. It represents the
#                CORBA servant object which will be accessed from the
#                network. All commands which can be executed on the
#                TangoSpecMotor are implemented in this file.
#
# project :     TANGO Device Server
#
# $Author:  $
#
# $Revision:  $
#
# $Log:  $
#
# copyleft :    European Synchrotron Radiation Facility
#               BP 220, Grenoble 38043
#               FRANCE
#
#=============================================================================
#          This file is generated by POGO
#    (Program Obviously used to Generate tango Object)
#
#         (c) - Software Engineering Group - ESRF
#=============================================================================
#


import PyTango
import sys

import sys
import time
import string
import math
import thread
import numpy
import threading

from SpecClient.SpecMotor import *
from SpecClient.SpecVariable import *
from SpecClient.SpecClientError import SpecClientError
from SpecClient import SpecEventsDispatcher
from SpecClient import SpecConnectionsManager

(NOTINITIALIZED, UNUSABLE, READY, MOVESTARTED, MOVING, ONLIMIT) = (0,1,2,3,4,5)
(NOLIMIT, LOWLIMIT, HIGHLIMIT) = (0,2,4)

#==================================================================
#   TangoSpecMotor Class Description:
#
#         A class to implement a SpecMotor as a Tango device. Spec will be accessed
#         via spec server usingg the SpecClient.
#
#==================================================================
#     Device States Description:
#
#   DevState.ON :
#   DevState.MOVING :
#   DevState.FAULT :
#==================================================================


#------------------------------------------------------------------
#    _SpecMotorA class
#------------------------------------------------------------------
class _SpecMotorA (SpecMotorA):

    def __init__(self,tango_spec_motor,motor,spec):
        #print "_SpecMotorA.__init__() called"
        #print "tango_spec_motor : ",tango_spec_motor
        self.tango_spec_motor = tango_spec_motor
        self.spec = spec
        self.motor = motor
        self.position = 0
        self.inited = 0
        self.spec_connected = 0
        self.state = NOTINITIALIZED
        #print "SpecMotorA.__init__(",self.motor,",",self.spec,") calling"
        #SpecMotorA.__init__(self, self.motor, self.spec)
        SpecMotorA.__init__(self)
        #print "_SpecMotorA.__init__() exiting"

    def connected(self):
        #print "connected"
        self.spec_connected = 1
        self.tango_spec_motor.stateChanged()
        self.position = self.getPosition()
        self.tango_spec_motor.positionChanged()


    def disconnected(self):
        #print "disconnected"
        self.spec_connected = 0
        self.tango_spec_motor.stateChanged()

    def motorPositionChanged(self, _position):
        print "position changed, new position = ", _position
        self.spec_connected = 1
        self.position = _position
        self.tango_spec_motor.positionChanged()

    def motorStateChanged(self, _state):
        self.spec_connected = 1
        self.state = _state
        self.tango_spec_motor.stateChanged()
        if self.state != NOTINITIALIZED:
            self.position = self.getPosition()
            self.tango_spec_motor.positionChanged()

    def connect(self):
        print "connect to motor ",self.motor, " spec ",self.spec
        SpecMotorA.connectToSpec(self, self.motor, self.spec)


class TangoSpecMotor(PyTango.Device_4Impl):

#--------- Add you global variables here --------------------------

#------------------------------------------------------------------
#    Device constructor
#------------------------------------------------------------------
    def __init__(self,cl, name):
        PyTango.Device_4Impl.__init__(self,cl,name)
        TangoSpecMotor.init_device(self)

#------------------------------------------------------------------
#    Device destructor
#------------------------------------------------------------------
    def delete_device(self):
        print "[Device delete_device method] for device",self.get_name()


#------------------------------------------------------------------
#    Device initialization
#------------------------------------------------------------------
    def init_device(self):
        self.info_stream("In ::init_device()")
        self.specclient_mngr = SpecConnectionsManager.SpecConnectionsManager(pollingThread=False)
        self.inited = 0
        self.limits_set = 0
        self.set_state(PyTango.DevState.ON)
        self.get_device_properties(self.get_device_class())
        self.info_stream( "property[specmotor] = %s" % self.device_property_list["Specmotor"][2])
        host_spec_motor = self.device_property_list["Specmotor"][2].split(":")
        if len(host_spec_motor) != 3:
            self.set_state(PyTango.DevState.FAULT)
            self.set_status("specmotor property error , property must contain 3 fields host:spec:motor (e.g. lid112:andy:phi) !")
            self.error_stream("specmotor property error , property must contain 3 fields host:spec:motor (e.g. lid112:andy:phi) !")
            
        else:
            self.info_stream("host = %s , spec session = %s , motor = %s" % (host_spec_motor[0],host_spec_motor[1],host_spec_motor[2]))
            self.spec = "%s:%s" % (host_spec_motor[0],host_spec_motor[1])
            self.motor = host_spec_motor[2]
            #
            # Create a synchronous spec access to get the data
            #       
            try:
                self.spec_motor_a = _SpecMotorA(self, self.motor, self.spec)
            #self.spec_motor = SpecMotor (self.motor, self.spec, 100)
            #self.position = self.spec_motor.getPosition()
            #print "motor position :", self.position

            except SpecClientError, error:
                self.error_stream( "Spec error : %s %s %s" % (self.motor, self.spec, error))

        self.set_change_event("State", True, False)
        self.set_change_event("Status", True, False)
        self.set_change_event("Position", True, False)

        #print self.get_name(), "::init_device() exiting"


#------------------------------------------------------------------
#    Always excuted hook method
#------------------------------------------------------------------
    def always_executed_hook(self):
        if self.inited == 0:
            self.spec_motor_a.connect()
            self.inited = 1
        #
        # TODO: find a better place to call the SPEC event dispatcher
        #
        #print "In ", self.get_name(), "::always_excuted_hook()"
        if self.spec_motor_a.spec_connected == 0:
            self.set_state(PyTango.DevState.FAULT)
            self.set_status("Motor in FAULT state because SPEC disconnected (hint: start the SPEC session)")
        #SpecEventsDispatcher.dispatch()
        elif self.limits_set == 0:
            self.limits_set = 1
            self.setLimits()

    def positionChanged(self):
        self.info_stream( "push position changed event %s " % self.spec_motor_a.position)
        self.position = self.spec_motor_a.position
        data = numpy.array([self.position], dtype=numpy.float64)
        self.push_change_event("Position", data)

    def stateChanged(self):
        self.info_stream( "push state changed event ")
        if self.inited == 1:
            if self.spec_motor_a.spec_connected == 0:
                self.set_state(PyTango.DevState.FAULT)
                self.set_status("Motor in FAULT state because SPEC disconnected (hint: start the SPEC session)")
            elif self.spec_motor_a.state == MOVING:
                self.set_state(PyTango.DevState.MOVING)
                self.set_status("Motor is MOVING")
            else:
                self.set_state(PyTango.DevState.ON)
                self.set_status("Motor is ON")
        self.push_change_event("State", self.get_state())
        self.push_change_event("Status", self.get_status())
        
    def setLimits(self):
        self.limits = self.spec_motor_a.getLimits()
        self.info_stream("set limits ")
        self.info_stream(self.limits)
        #attributes = self.get_device_attr()
        pos_attr = self.get_device_attr().get_attr_by_name("Position")
        multi_prop = pos_attr.get_properties()
        multi_prop.max_value = str(self.limits[1])
        multi_prop.min_value = str(self.limits[0])
        print multi_prop
        pos_attr.set_properties(multi_prop,self)
        #multi_prop = pos_attr.get_properties()
        #print multi_prop
        self.limits_set = 1

#==================================================================
#
#    TangoSpecMotor read/write attribute methods
#
#==================================================================
#------------------------------------------------------------------
#    Read Attribute Hardware
#------------------------------------------------------------------
    def read_attr_hardware(self,data):
        #print "In ", self.get_name(), "::read_attr_hardware()"
        # the client does not always receive the motor state change from spec
        # therefore do a synchronous read on the motor state to be sure it is updated
        self.spec_motor_state = self.spec_motor_a.getState()
        if self.spec_motor_a.spec_connected == 0:
            self.set_state(PyTango.DevState.FAULT)
            self.set_status("Motor in FAULT state because SPEC disconnected (hint: start the SPEC session)")
        elif self.spec_motor_state == MOVING:
            self.set_state(PyTango.DevState.MOVING)
            self.set_status("Motor is MOVING")
        else:
            self.set_state(PyTango.DevState.ON)
            self.set_status("Motor is ON")



#------------------------------------------------------------------
#    Read Position attribute
#------------------------------------------------------------------
    def read_position(self, attr):
        #print "In ", self.get_name(), "::read_position()"
        
        #    Add your own code here
        
        # do a synchronous read of the position instead of
        # relying only on the position sent as an event
        # this is to increase the reliability of the position
        # read - aka "belt and braces" approach
        self.position = self.spec_motor_a.getPosition()
        self.debug_stream( "read synchronous position = %f"% self.position) 
        attr.set_value(self.position)


#------------------------------------------------------------------
#    Write position attribute
#------------------------------------------------------------------
    def write_position(self, attr):
        #print "In ", self.get_name(), "::write_position()"
        ##data=[]
        ##attr.get_write_value(data)
        data = attr.get_write_value()
        self.debug_stream( "move motor to position = %s "% str(data))

        #    Add your own code here
        try:
            ##self.spec_motor_a.move(data[0])
            self.spec_motor_a.move(data)
            self.set_state(PyTango.DevState.MOVING)
            self.set_status("Motor is MOVING")

        except SpecClientError, error:
            self.error_stream( "Spec error : %s %s %s" % (self.motor, self.spec, error))

#------------------------------------------------------------------
#    Read dial attribute
#------------------------------------------------------------------
    def read_dial(self, attr):
        #print "In ", self.get_name(), "::read_Dial()"
        
        #    Add your own code here
        
        self.dial = self.spec_motor_a.getDialPosition()
        self.debug_stream( "read synchronous dial = %f"% self.dial) 
        attr.set_value(self.dial)
        
        
        
#------------------------------------------------------------------
#    Read offset attribute
#------------------------------------------------------------------
    def read_offset(self, attr):
        #print "In ", self.get_name(), "::read_offset()"
        
        #    Add your own code here
        
        self.offset = self.spec_motor_a.getOffset()
        self.debug_stream( "read synchronous offset = %f"% self.offset) 
        attr.set_value(self.offset)
        
#------------------------------------------------------------------
#    Read dial attribute
#------------------------------------------------------------------
    def read_velocity(self, attr):
        #print "In ", self.get_name(), "::read_velocity()"
        
        #    Add your own code here
        # TODO - find out why velocity does not work, replaced by base_rate for now
        #self.velocity = self.spec_motor_a.getParameter("velocity")
        self.velocity = self.spec_motor_a.getParameter("base_rate")
        self.debug_stream( "read synchronous velocity = %f"% self.velocity) 
        attr.set_value(self.velocity)
        
#------------------------------------------------------------------
#    Read acceleration attribute
#------------------------------------------------------------------
    def read_acceleration(self, attr):
        #print "In ", self.get_name(), "::read_acceleration()"
        
        #    Add your own code here
        
        self.acceleration = self.spec_motor_a.getParameter("acceleration")
        self.debug_stream( "read synchronous acceleration = %f"% self.acceleration) 
        attr.set_value(self.acceleration)
        
#------------------------------------------------------------------
#    Read backlash attribute
#------------------------------------------------------------------
    def read_backlash(self, attr):
        #print "In ", self.get_name(), "::read_backlash()"
        
        #    Add your own code here
        
        self.backlash = self.spec_motor_a.getParameter("backlash")
        self.debug_stream( "read synchronous backlash = %f"% self.backlash) 
        attr.set_value(self.backlash)
        


#==================================================================
#
#    TangoSpecMotor command methods
#
#==================================================================

#------------------------------------------------------------------
#       Abort command:
#
#       Description: 
#       argin:  DevVarStringArray       
#       argout: DevString       
#------------------------------------------------------------------
    def Abort(self):
        try:
            self.spec_motor_a.stop()

        except SpecClientError, error:
            self.error_stream( "Spec error : %s %s %s" % (self.motor, self.spec, error))

#------------------------------------------------------------------
#       SpecClientPoll command:
#
#       Description: 
#       argin:  DevVoid
#       argout: DevVoid
#------------------------------------------------------------------
    def SpecClientPoll(self):
        #self.info_stream( "specclient_poll() ")
        self.specclient_mngr.poll()


#==================================================================
#
#    TangoSpecMotorClass class definition
#
#==================================================================
class TangoSpecMotorClass(PyTango.DeviceClass):

    #    Class Properties
    class_property_list = {
        }


    #    Device Properties
    device_property_list = {
        'Specmotor':
            [PyTango.DevString,
            "Name of spec session and motor e.g. host:spec:m0",
             "lid112:andy:phi" ],
        }


    #    Command definitions
    cmd_list = {
            'Abort':
                [[PyTango.DevVoid, ""],
                [PyTango.DevVoid, ""]],
            'SpecClientPoll':
                [[PyTango.DevVoid, ""],
                [PyTango.DevVoid, ""]],
                # specifying the polling period in the source needs
                # recent version of the mysql database (>5)
                # for now configure the polling for one of the
                # devices in the server ... andy 19jun2012
                #[PyTango.DevVoid, ""],{'Polling period':50}],

        }


    #    Attribute definitions
    attr_list = {
        'position':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ_WRITE]],
        'dial':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ]],
        'offset':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ]],
         'velocity':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ]],
        'acceleration':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ]],
        'backlash':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ]],
        }

#------------------------------------------------------------------
#    _SpecEventDispatcherThread function
#------------------------------------------------------------------
    def _spec_event_dispatcher_thread(self):
        print 'Start _SpecEventDispatcherThread()'
        if SpecConnectionsManager._SpecConnectionsManagerInstance == None:
            print "_spec_event_dispatcher_thread(): create SpecConnetionsManager"
            spec_mngr = SpecConnectionsManager.SpecConnectionsManager(pollingThread=False)
            while True:
                SpecConnectionsManager._SpecConnectionsManagerInstance.poll()
                #SpecEventsDispatcher.dispatch(-1)
                time.sleep(.01)


#------------------------------------------------------------------
#    TangoSpecMotorClass Constructor
#------------------------------------------------------------------
    def __init__(self, name):
        PyTango.DeviceClass.__init__(self, name)
        self.set_type(name);
        #print "In TangoSpecMotorClass  constructor"
        # do not create thread - assume polling is done in TangoSpec class
        #thread_args= self,
        #thread.start_new_thread(TangoSpecMotorClass._spec_event_dispatcher_thread,thread_args)

#==================================================================
#
#    TangoSpecMotor class main method
#
#==================================================================
if __name__ == '__main__':
    try:
        py = PyTango.Util(sys.argv)
        py.add_TgClass(TangoSpecMotorClass,TangoSpecMotor,'TangoSpecMotor')
        U = PyTango.Util.instance()
        U.set_serial_model(PyTango.SerialModel.BY_PROCESS) # to limit to one thread
        U.server_init()
        U.server_run()

    except PyTango.DevFailed,e:
        print '-------> Received a DevFailed exception:',e
    except Exception,e:
        print '-------> An unforeseen exception occured....',e
